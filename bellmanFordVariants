import numpy as np
import random

# FONCTION 

# convertir matrice pondérée en binaire
def conversion(mat):
    convertis = np.copy(mat)
    for x in range(len(convertis)):
        for y in range(len(convertis)):
            if mat[x][y] == np.inf or int(mat[x][y]) == 0 :
                convertis[x][y] = 0
            else:
                convertis[x][y] = 1
    return convertis
    

# pris dans les corrections de tp
def parcour_largeur(M, d):
    mat = conversion(M)
    n = len(M)
    couleur = {}     # On colorie tous les sommets en blanc et s (départ) en vert
    for i in range(n):
        couleur[i] = 'blanc'
    couleur[d] = 'vert'
    file=[d]
    Resultat=[d]
    while file !=[]:
        i=file[0]           # on prend le premier terme de la file
        for j in range(n):  # On enfile les successeurs de i encore blancs:
            if (mat[file[0]][j]==1 and couleur[j]=='blanc'):
                file.append(j)
                couleur[j]='vert' # On les colorie en vert (sommets visités)
                Resultat.append(j) # On les place dans la liste Resultat
        file.pop(0) # on défile i (on retire le premier élément)
    return Resultat


def parcour_profondeur(m,d):
    mat = conversion(m)
    n=len(mat)       # taille du tableau = nombre de sommets
    couleur={}     # On colorie tous les sommets en blanc et s en vert
    for i  in range(n):
        couleur[i]='blanc'
    couleur[d]='vert'
    pile=[d]       # on initialise la pile à s
    Resultat=[d] # on initialise la liste des résultats à s
    
    while pile !=[]: # tant que la pile n'est pas vide,
        i=pile[-1]          # on prend le dernier sommet i de la pile
        Succ_blanc=[]       # on crée la liste de ses successeurs non déjà visités (blancs)
        for j in range(n):
            if (mat[i,j]==1 and couleur[j]=='blanc'):
                Succ_blanc.append(j)
        if Succ_blanc!=[]:  # s'il y en a,
            v= Succ_blanc[0]    # on prend le premier (si on veut l'ordre alphabétique)
            couleur[v]='vert'   # on le colorie en vert, 
            pile.append(v)      # on l'empile
            Resultat.append(v)  # on le met en liste rsultat
        else:               # sinon:
            pile.pop()          # on sort i de la pile
    return Resultat


def hasard(mat):
    fleche = []
    for i in range(0,len(mat)-1):
        for y in range(0,len(mat)-1):
            if mat[i][y] != np.inf :
                fleche.append(int(mat[i][y]))
    return random.sample(fleche, len(fleche))
